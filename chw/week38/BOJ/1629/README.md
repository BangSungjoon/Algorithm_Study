## 모듈러 거듭제곱
1. 지수를 이진수로 표현
2. 거듭제곱을 분해
3. 제곱을 반복해서 필요한 거듭제곱들을 구함
---

=== 모듈러 거듭제곱 과정 시각화 ===
계산: 2^13 mod 1000
지수 13의 이진수: 1101

Step 1: exp=13, bit=1
  현재 result=1, base=2
  bit=1이므로: result = (1 × 2) mod 1000 = 2
  base = (2 × 2) mod 1000 = 4

Step 2: exp=6, bit=0
  현재 result=2, base=4
  bit=0이므로: result 그대로
  base = (4 × 4) mod 1000 = 16

Step 3: exp=3, bit=1
  현재 result=2, base=16
  bit=1이므로: result = (2 × 16) mod 1000 = 32
  base = (16 × 16) mod 1000 = 256

Step 4: exp=1, bit=1
  현재 result=32, base=256
  bit=1이므로: result = (32 × 256) mod 1000 = 192

최종 결과: 192

=== 성능 비교 (큰 수) ===
2^100000 mod 1000007
직접 구현: 351226 (시간: 0.000002초)
내장 함수: 351226 (시간: 0.000001초)
결과 일치: True

=== 일반 거듭제곱 vs 모듈러 거듭제곱 ===
2^20 = 1048576
이것을 1000로 나눈 나머지: 576
모듈러 거듭제곱으로 직접 계산: 576
→ 결과는 같지만, 큰 수에서는 중간 계산 과정이 완전히 다름!

### 거듭제곱 분할 정복
1. 기본 아이디어:
a^b를 계산하려면 a^(b/2)를 먼저 구하고, 그것을 제곱

2. 두 가지 경우:
b가 짝수: a^b = a^(b/2) × a^(b/2)
b가 홀수: a^b = a^(b/2) × a^(b/2) × a

```
def power(a, b, c):
    if b == 0:
        return 1

    x = power(a, b//2, c)

    if b % 2 == 0:
        return x * x % c
    else:
        return x * x * a % c
```    

### 무슨 말인지 모르겠다...
그냥 큰 숫자면 내장 함수 pow(a, b, c) 쓰자
